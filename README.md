# Antlr-project
This is a compiler made using antlr and java. 
The project involves implementing different phases of a translator/ compiler for a simple language implemented them using ANTLR.


Step 0  
Setup the development/ programming/ submission environments including ANTLR, and Github (optional). Identify project partners (if any). Familiarize with Osprey server. 

Step 1  
Write a lexer to scan a program written in the language given on the course web page. The output of this will be one line for each token encountered, which contains the token and its type. 

Step 2  
Write a parser for the given grammar. Lexical analysis will be done with your Step 1 code. Parser error recovery does not need to be implemented. However, the parser must stop correctly upon a detected syntax error. 

Step 3  
Implement the semantic actions associated with variable declaration. The symbol table entry object has an identifier name field and a type field. In particular, when an integer or float variable declaration is encountered, create an entry whose type field is integer (or “float”) and its return type to N/A. The string corresponding to the identifier name can either be part of the identifier entry in the symbol table or can be part of an external string table that is pointed to by the symbol table entry. When a new scope is encountered, a new symbol table should be created. Thus, when entering a function, or the body of an IF, ELSE, or WHILE loop a new symbol table needs to be created, and the symbols declared in that scope added to the symbol table. The output of your program should be a listing of the type of scope the symbol table is for (an IF, ELSE, WHILE, FUNCTION or PROGRAM), the name, if any of the scope, and the symbol table entries, with each line containing the variable name and its type. 


Step 4 
Process assignment statements, expressions. In this assignment, an internal representation (IR) of the program will be provided. You are also welcome to build the IR afresh by first constructing an Abstract Syntax Tree (AST), then producing an IR from that tree (but this is optional). This IR consists of a list of nodes, one node per IR statement. The nodes will appear in the list in the order they are generated by the semantic routines. The semantic actions for each sub-expression will produce code of the form <lhs>=<1st operand> <operation> <2nd operand>. The node will contain this information and pointers to the operation that is immediately reachable after this node. Implement the read and write statements. This step may also require performing optimization and register allocation.
